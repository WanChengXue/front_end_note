# JS进阶操作
## 1. 作用域
### 1.1 局部作用域
和python差不多，函数内部的变量外部无法访问，块级作用域，只要是`{}`包起来声明的变量只在块中有效。推荐使用`let, const`，因为`var`没有块作用域

### 1.2 全局作用域
最外层的就是全局作用域，函数内部不声明直接赋值，也是全局变量

### 1.3 作用域链
底层的变量查找机制
- 在函数被执行的时候，会有限查找当前函数作用域中查找变量
- 如果当前作用域查找不到则会一次逐级查找父级作用域直到全局作用域
- 子作用域可以访问父作用域，父作用域无法访问子作用域

### 1.4 JS的垃圾回收GC
内存的生命周期
- 内存分配：当我们声明变量，函数，对象的时候，系统会自动给它们分配内存
- 内存使用：读写内存，也就是使用变量，函数等
- 内存回收：使用完毕，由垃圾回收器自动回收不再使用的内存

说明：
- 全局变量一般不会回收
- 一般情况下局部变量的值不用了会被自动回收掉

内存泄露：程序中分配的内存由于某种原因程序未释放或无法释放叫内存泄露

- 引用计数垃圾回收
- 标记计数法回收（扫描，根出发 -> 找不到，就回收）

### 1.5 JS的闭包
一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域。闭包 = 内层函数+外层函数的变量

### 1.6 变量提升
讲所有var声明的变量提升到当前作用域的最前面。只提升声明，不提升赋值，不推荐使用

## 2. 函数进阶
### 2.1 函数提升
函数被声明之前就可以被调用，同样只提升声明。也不推荐使用

### 2.2 函数的参数
函数的动态参数，类似Python的`*args, **kwargs`。在js中，每一个函数都有一个arguments，只存在函数内部，如果想要写就：
```javascript
function fn(...arr){}
```
表示剩余参数，和python一样，表示可变参数，类似，`*args`，因此可以和python一样定义函数：
```javascript
function fn(a, b, ...arr){}
```
使用...得到的arr是一个真数组，因此有pop和push操作，使用`arguments`则是一个伪数组。同样和python一样，可以对数组进行结构操作，调用一个函数`fn(...arr)`，会自动拆分成三个元素

### 2.3 箭头函数
- 目的：引入箭头函数的目的是为了更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更加简洁
- 使用场景：箭头函数更适用于那些本来需要匿名函数的地方，使用方法`() => {}`，等价`function () {}`，如果只有一个形参的时候可以省略小括号`const fn = x => {}`，如果函数体只有一句，则`const fn = x => x+x`，大括号也可省略，结果回返回，只是return省略了
- 箭头函数可以直接返回一个对象需要加小括号，如`x => ({test: x})`
- 箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this，DOM事件callback为了简便还是不推荐使用箭头函数，因为在callback函数中this指向window

### 2.4 解构赋值
类似python一样`[a,b,c] = arr`，快速交换两个变量的值`[a,b] = [b,a]`，两种特殊情况需要增加分号：
- 立即执行函数`(function(){})();`
- 前面有代码，则以数组开头的需要加，如：
```javascript
let a = 1
let b = 2
;[a,b] = [b,a]
```

### 2.5 对象解构
 对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法
 - `赋值运算符 = 左侧的{}用于批量声明变量`，右侧对象的属性值将被赋值给左侧的变量
 - 对象属性的值将被赋值给与`属性名相同`的变量
 - 解构的变量名不要和外面的变量名发生冲突报错
 - 对象中找不到与变量名一致的属性值变量值为undefined
 - 如果要改名，写法为`{旧变量名：新变量名} = {}`进行解构
 - 多级对象解构需要冒号隔开，`{一级属性：{二级属性}} = {}`

## 3. 构造函数
### 3.1 深入对象
- `const a = {'a': 1}`
- `const a = new Object({'uname': 'test'})`，创建对象
- 使用构造函数来快速创建多个类似的对象，约定函数的第一个字母用大写开头，只能由new来进行实例，回想和python一样，就是把self变成this。
- 最后，只要是累，统一使用class创建
```javascript
class Color{
    // 定义私有变量
    #value
    constructor(a,b,c){
        this.a = a
        this.b = b
        this.c = c
        // 构造赋值
        this.#value = a + b +c
    }

    format_string(){
        // 成员函数
        console.log(`${this.a} + ${this.b} + ${this.c} = ${this.#value}`)

    static say(){
        // 静态函数，通过类进行调用，实例对象无法进行调用
        console.log('hello')
    }
    }
}

```


### 3.2 内置构造函数
js最主要的数据类型有六种：string，number，undefined，bool，null，object。在js的底层会将简单数据类型包装成对象，因此可以使用属性和方法

#### 3.1.1 内置对象
- `Object.keys(对象)`，这样就能够得到所有的键
- `Object.values(对象)`，获取所有的属性值
- `Object.assign(新对象，被拷贝的对象)`，这属于浅拷贝，类似python的copy

#### 3.1.2 array
- `forEach`, 遍历数组，不返回数组，经常用于查找遍历数组元素
- `map`，迭代数组，返回新数组，经常是要对数组中的每一个元素进行相同的操作
- `filter`，过滤数组，返回新数组，对一个原始数组进行处理后得到新的
- `reduce`，累计器，返回累计处理的结果，使用方法`arr.reduce(function(上一次的值，当前的值){}, 起始值)`，执行过程：
  - 如果初始值，则上一次值就以数组的第一个数组元素的值
  - 每一次循环，把返回值作为下一次循环的上一次值
  - 如果有起始值，则起始值作为上一次值

## 4. 面向对象
### 4.1 原型
- 构造函数是通过原型来分配函数是所有对象所共享的
- js规定，每一个构造函数都有一个prototype属性，指向同一个对象，也就是我们说的原型对象，`class.prototype`
- 原型对象可以挂载函数，对象实例化
- 公共的属性写在构造函数中，公共的方法写在原型身上
